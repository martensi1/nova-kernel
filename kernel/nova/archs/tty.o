# 0 "../../../tty.cpp"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "../../../tty.cpp"
# 24 "../../../tty.cpp"
# 1 "../../../../nova/tty.h" 1
# 27 "../../../../nova/tty.h"
# 1 "../../../../nova/common.h" 1
# 27 "../../../../nova/common.h"
# 1 "../../../../nova/common/types.h" 1
# 27 "../../../../nova/common/types.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/12/include/stdint.h" 1 3 4
# 11 "/usr/lib/gcc/x86_64-linux-gnu/12/include/stdint.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/12/include/stdint-gcc.h" 1 3 4
# 34 "/usr/lib/gcc/x86_64-linux-gnu/12/include/stdint-gcc.h" 3 4

# 34 "/usr/lib/gcc/x86_64-linux-gnu/12/include/stdint-gcc.h" 3 4
typedef signed char int8_t;


typedef short int int16_t;


typedef int int32_t;


typedef long long int int64_t;


typedef unsigned char uint8_t;


typedef short unsigned int uint16_t;


typedef unsigned int uint32_t;


typedef long long unsigned int uint64_t;




typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;
typedef long long int int_least64_t;
typedef unsigned char uint_least8_t;
typedef short unsigned int uint_least16_t;
typedef unsigned int uint_least32_t;
typedef long long unsigned int uint_least64_t;



typedef signed char int_fast8_t;
typedef int int_fast16_t;
typedef int int_fast32_t;
typedef long long int int_fast64_t;
typedef unsigned char uint_fast8_t;
typedef unsigned int uint_fast16_t;
typedef unsigned int uint_fast32_t;
typedef long long unsigned int uint_fast64_t;




typedef int intptr_t;


typedef unsigned int uintptr_t;




typedef long long int intmax_t;
typedef long long unsigned int uintmax_t;
# 12 "/usr/lib/gcc/x86_64-linux-gnu/12/include/stdint.h" 2 3 4
# 28 "../../../../nova/common/types.h" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/12/include/stddef.h" 1 3 4
# 145 "/usr/lib/gcc/x86_64-linux-gnu/12/include/stddef.h" 3 4
typedef int ptrdiff_t;
# 214 "/usr/lib/gcc/x86_64-linux-gnu/12/include/stddef.h" 3 4
typedef unsigned int size_t;
# 424 "/usr/lib/gcc/x86_64-linux-gnu/12/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));






  __float128 __max_align_f128 __attribute__((__aligned__(__alignof(__float128))));

} max_align_t;






  typedef decltype(nullptr) nullptr_t;
# 29 "../../../../nova/common/types.h" 2



# 31 "../../../../nova/common/types.h"
typedef int8_t s8;
typedef int16_t s16;
typedef int32_t s32;


typedef uint8_t u8;
typedef uint16_t u16;
typedef uint32_t u32;
# 28 "../../../../nova/common.h" 2
# 1 "../../../../nova/common/macros.h" 1
# 29 "../../../../nova/common.h" 2
# 1 "../../../../nova/sync/spin_lock.h" 1
# 38 "../../../../nova/sync/spin_lock.h"
class SpinLock
{
public:






    SpinLock(bool irqSave=true);





    void aqquire();





    void release();

private:
    void inline __attribute__((always_inline)) lock()
    {
        while (__atomic_test_and_set(&lock_, 2))
        {
            __builtin_ia32_pause();
        }
    }

    void inline __attribute__((always_inline)) unlock()
    {
        __atomic_clear(&lock_, 3);
    }

    volatile u32 lock_;
    unsigned long cpuFlags_;
    bool irqSave_;
};
# 30 "../../../../nova/common.h" 2
# 1 "../../../../nova/sync/spin_guard.h" 1
# 27 "../../../../nova/sync/spin_guard.h"
# 1 "../../../../nova/sync/spin_lock.h" 1
# 28 "../../../../nova/sync/spin_guard.h" 2
# 36 "../../../../nova/sync/spin_guard.h"
class SpinGuard
{
public:






    inline __attribute__((always_inline)) SpinGuard(SpinLock& lock) : lock_(lock)
    {
        lock_.aqquire();
    }





    inline __attribute__((always_inline)) ~SpinGuard()
    {
        lock_.release();
    }





    explicit SpinGuard(const SpinGuard&) = delete;





    explicit SpinGuard(SpinGuard&&) = delete;

private:
    SpinLock& lock_;
};
# 31 "../../../../nova/common.h" 2
# 28 "../../../../nova/tty.h" 2
# 1 "../../../../nova/console/driver.h" 1
# 32 "../../../../nova/console/driver.h"
struct ConsoleDriver {
    char name[10];

    bool (*isAvailable)();
    void (*initialize)();
    void (*writeChar)(const char c);
    void (*writeLineFeed)();
    void (*enableCursor)();
    void (*updateCursor)();
    void (*disableCursor)();
    void (*flush)();
    void (*clear)();
};
# 29 "../../../../nova/tty.h" 2
# 1 "../../../../nova/common/cbuffer.h" 1
# 29 "../../../../nova/common/cbuffer.h"
# 1 "../../../../../libc/include/libc/string.h" 1



# 1 "/usr/lib/gcc/x86_64-linux-gnu/12/include/stddef.h" 1 3 4
# 5 "../../../../../libc/include/libc/string.h" 2

void* memcpy(void *dst, const void* src, int n);
void* memset(void* ptr, int value, size_t num);

char* strcat(char* destination, const char* source);

int strcmp(const char* str1, const char* str2);
int strncmp(const char* str1, const char* str2, size_t num);

char* strcpy(char* destination, const char* source);
char* strncpy(char* destination, const char* source, size_t num);

size_t strlen(const char* str);
# 30 "../../../../nova/common/cbuffer.h" 2






template<int N>
class CircularBuffer
{
public:




    CircularBuffer() :
        head_(0),
        full_(false)
    {
        clear();
    }
# 58 "../../../../nova/common/cbuffer.h"
    void push(const char* data, u32 size)
    {
        for (u32 i = 0; i < size; i++)
        {
            buffer_[head_] = data[i];
            head_ = (head_ + 1) % N;
        }

        if (head_ + size >= N)
        {
            full_ = true;
        }
    }

    void read(char* data)
    {
        if (full_)
        {
            memcpy(data, buffer_ + head_, N - head_);
            memcpy(data + N - head_, buffer_, head_);
        }
        else
        {
            memcpy(data, buffer_, head_);
        }
    }

    void clear()
    {
        for (int i = 0; i < N; i++)
        {
            buffer_[i] = 0;
        }

        head_ = 0;
    }

    bool inline __attribute__((always_inline)) isFull() const
    {
        return full_;
    }

    u32 size() const
    {
        if (full_)
        {
            return N;
        }
        else
        {
            return head_;
        }
    }

    constexpr u32 inline __attribute__((always_inline)) capacity() const
    {
        return N;
    }

private:
    u8 buffer_[N];

    u32 head_;
    bool full_;
};
# 30 "../../../../nova/tty.h" 2


namespace nova
{
    namespace priv
    {
        class TerminalInterface
        {
        public:







            TerminalInterface(const char* name, ConsoleDriver* driver);







            bool inline __attribute__((always_inline)) IsAvailable()
            {
                return console_->isAvailable();
            }







            bool Enable();





            void Disable();
# 80 "../../../../nova/tty.h"
            void Write(const char* data, size_t size);







            void Write(const char* str);





            void Flush();





            void Clear();







            bool inline __attribute__((always_inline)) IsEnabled() const
            {
                return enabled_;
            }







            inline __attribute__((always_inline)) const char* GetName() const
            {
                return name_;
            }

        private:
            inline __attribute__((always_inline)) void writeData(const char* data, size_t size);
            inline __attribute__((always_inline)) void writeData(const char* str);

            const char* name_;
            bool enabled_;

            SpinLock lock_;
            ConsoleDriver* console_;

        };
    }





    void TerminalScanDrivers();





    void inline __attribute__((always_inline)) InitializeTerminal()
    {
        TerminalScanDrivers();
    }





    void TerminalClear();
# 165 "../../../../nova/tty.h"
    void TerminalWrite(const char* data, size_t size);







    void TerminalWrite(const char* str);





    void TerminalFlush();

}
# 25 "../../../tty.cpp" 2






extern struct ConsoleDriver vgaDriver;
extern struct ConsoleDriver serialDriver;

static CircularBuffer<1024> history;

using namespace nova::priv;
static TerminalInterface interfaces[2] = {
    { "Screen", &vgaDriver },
    { "Serial", &serialDriver }
};


namespace nova
{
    namespace priv
    {

        TerminalInterface::TerminalInterface(const char* name, ConsoleDriver* driver)
            : name_(name)
            , console_(driver)
        {
        }


        bool TerminalInterface::Enable()
        {
            SpinGuard guard(lock_);

            if (enabled_) {
                return false;
            }

            console_->initialize();
            console_->clear();

            console_->enableCursor();
            console_->updateCursor();

            writeData("Terminal initialized (");
            writeData(console_->name);
            writeData(")\n");

            enabled_ = true;
            return true;
        }


        void TerminalInterface::Disable()
        {
            SpinGuard guard(lock_);

            if (!enabled_) {
                return;
            }

            console_->clear();
            console_->disableCursor();
            enabled_ = false;
        }


        void TerminalInterface::Write(const char* data, size_t size)
        {
            SpinGuard guard(lock_);
            writeData(data, size);
        }



        void TerminalInterface::Write(const char* str)
        {
            size_t length = strlen(str);
            writeData(str, length);
        }


        void TerminalInterface::Flush()
        {
            SpinGuard guard(lock_);
            console_->flush();
        }


        void TerminalInterface::Clear()
        {
            SpinGuard guard(lock_);
            console_->clear();
        }


        void TerminalInterface::writeData(const char* data, size_t size)
        {
            for (size_t i = 0; i < size; i++) {
                char c = data[i];

                if (c == '\n') {
                    console_->writeLineFeed();
                    continue;
                }

                console_->writeChar(c);
            }

            console_->updateCursor();
            console_->flush();
        }


        void TerminalInterface::writeData(const char* str)
        {
            size_t length = strlen(str);
            writeData(str, length);
        }
    }


    void TerminalScanDrivers()
    {
        for (size_t i = 0; i < (sizeof(interfaces) / sizeof(interfaces[0])); i++) {
            auto interface = &interfaces[i];

            if (interface->IsAvailable()) {
                bool enabled = interface->Enable();

                if (enabled) {
                    char buffer[1024];
                    history.read(buffer);
                    interface->Write(buffer, history.size());
                }
            }
            else if (!interface->IsAvailable()) {
                interface->Disable();
            }
        }
    }


    void TerminalClear()
    {
        for (size_t i = 0; i < (sizeof(interfaces) / sizeof(interfaces[0])); i++) {
            auto interface = &interfaces[i];

            if (interface->IsEnabled()) {
                interface->Clear();
            }
        }

        history.clear();
    }


    void TerminalWrite(const char* data, size_t size)
    {
        history.push(data, size);

        for (size_t i = 0; i < (sizeof(interfaces) / sizeof(interfaces[0])); i++) {
            auto interface = &interfaces[i];

            if (interface->IsEnabled()) {
                interface->Write(data, size);
            }
        }
    }


    void TerminalWrite(const char* str)
    {
        size_t length = strlen(str);
        TerminalWrite(str, length);
    }


    void TerminalFlush()
    {
        for (size_t i = 0; i < (sizeof(interfaces) / sizeof(interfaces[0])); i++) {
            auto interface = &interfaces[i];

            if (interface->IsEnabled()) {
                interface->Flush();
            }
        }
    }
}
