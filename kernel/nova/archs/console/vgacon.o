# 0 "../../../console/vgacon.cpp"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "../../../console/vgacon.cpp"
# 24 "../../../console/vgacon.cpp"
# 1 "../../../../nova/console/driver.h" 1
# 32 "../../../../nova/console/driver.h"
struct ConsoleDriver {
    char name[10];

    bool (*isAvailable)();
    void (*initialize)();
    void (*writeChar)(const char c);
    void (*writeLineFeed)();
    void (*enableCursor)();
    void (*updateCursor)();
    void (*disableCursor)();
    void (*flush)();
    void (*clear)();
};
# 25 "../../../console/vgacon.cpp" 2
# 1 "../../../../nova/cpu/sysbus.h" 1
# 27 "../../../../nova/cpu/sysbus.h"
# 1 "../../../../nova/common.h" 1
# 27 "../../../../nova/common.h"
# 1 "../../../../nova/common/types.h" 1
# 27 "../../../../nova/common/types.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/12/include/stdint.h" 1 3 4
# 11 "/usr/lib/gcc/x86_64-linux-gnu/12/include/stdint.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/12/include/stdint-gcc.h" 1 3 4
# 34 "/usr/lib/gcc/x86_64-linux-gnu/12/include/stdint-gcc.h" 3 4

# 34 "/usr/lib/gcc/x86_64-linux-gnu/12/include/stdint-gcc.h" 3 4
typedef signed char int8_t;


typedef short int int16_t;


typedef int int32_t;


typedef long long int int64_t;


typedef unsigned char uint8_t;


typedef short unsigned int uint16_t;


typedef unsigned int uint32_t;


typedef long long unsigned int uint64_t;




typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;
typedef long long int int_least64_t;
typedef unsigned char uint_least8_t;
typedef short unsigned int uint_least16_t;
typedef unsigned int uint_least32_t;
typedef long long unsigned int uint_least64_t;



typedef signed char int_fast8_t;
typedef int int_fast16_t;
typedef int int_fast32_t;
typedef long long int int_fast64_t;
typedef unsigned char uint_fast8_t;
typedef unsigned int uint_fast16_t;
typedef unsigned int uint_fast32_t;
typedef long long unsigned int uint_fast64_t;




typedef int intptr_t;


typedef unsigned int uintptr_t;




typedef long long int intmax_t;
typedef long long unsigned int uintmax_t;
# 12 "/usr/lib/gcc/x86_64-linux-gnu/12/include/stdint.h" 2 3 4
# 28 "../../../../nova/common/types.h" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/12/include/stddef.h" 1 3 4
# 145 "/usr/lib/gcc/x86_64-linux-gnu/12/include/stddef.h" 3 4
typedef int ptrdiff_t;
# 214 "/usr/lib/gcc/x86_64-linux-gnu/12/include/stddef.h" 3 4
typedef unsigned int size_t;
# 424 "/usr/lib/gcc/x86_64-linux-gnu/12/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));






  __float128 __max_align_f128 __attribute__((__aligned__(__alignof(__float128))));

} max_align_t;






  typedef decltype(nullptr) nullptr_t;
# 29 "../../../../nova/common/types.h" 2



# 31 "../../../../nova/common/types.h"
typedef int8_t s8;
typedef int16_t s16;
typedef int32_t s32;


typedef uint8_t u8;
typedef uint16_t u16;
typedef uint32_t u32;
# 28 "../../../../nova/common.h" 2
# 1 "../../../../nova/common/macros.h" 1
# 29 "../../../../nova/common.h" 2
# 1 "../../../../nova/sync/spin_lock.h" 1
# 38 "../../../../nova/sync/spin_lock.h"
class SpinLock
{
public:






    SpinLock(bool irqSave=true);





    void aqquire();





    void release();

private:
    void inline __attribute__((always_inline)) lock()
    {
        while (__atomic_test_and_set(&lock_, 2))
        {
            __builtin_ia32_pause();
        }
    }

    void inline __attribute__((always_inline)) unlock()
    {
        __atomic_clear(&lock_, 3);
    }

    volatile u32 lock_;
    unsigned long cpuFlags_;
    bool irqSave_;
};
# 30 "../../../../nova/common.h" 2
# 1 "../../../../nova/sync/spin_guard.h" 1
# 27 "../../../../nova/sync/spin_guard.h"
# 1 "../../../../nova/sync/spin_lock.h" 1
# 28 "../../../../nova/sync/spin_guard.h" 2
# 36 "../../../../nova/sync/spin_guard.h"
class SpinGuard
{
public:






    inline __attribute__((always_inline)) SpinGuard(SpinLock& lock) : lock_(lock)
    {
        lock_.aqquire();
    }





    inline __attribute__((always_inline)) ~SpinGuard()
    {
        lock_.release();
    }





    explicit SpinGuard(const SpinGuard&) = delete;





    explicit SpinGuard(SpinGuard&&) = delete;

private:
    SpinLock& lock_;
};
# 31 "../../../../nova/common.h" 2
# 28 "../../../../nova/cpu/sysbus.h" 2


namespace nova
{



    static inline void WriteIO(const u16 port, const u8 value)
    {
        asm volatile("out %%al, %%dx" : : "a"(value), "d"(port));
    }




    static inline u8 ReadIO(const u16 port)
    {
        u8 value;
        asm volatile("in %%dx, %%al" : "=a"(value) : "d"(port));

        return value;
    }
}
# 26 "../../../console/vgacon.cpp" 2


using namespace nova;
# 48 "../../../console/vgacon.cpp"
static const size_t VGA_WIDTH = 80;
static const size_t VGA_HEIGHT = 20;

static u16* videoBuffer;
static u8 writeColor;

static size_t column;
static size_t row;


enum VGAColor {
    VGA_COLOR_BLACK = 0,
    VGA_COLOR_BLUE = 1,
    VGA_COLOR_GREEN = 2,
    VGA_COLOR_CYAN = 3,
    VGA_COLOR_RED = 4,
    VGA_COLOR_MAGENTA = 5,
    VGA_COLOR_BROWN = 6,
    VGA_COLOR_LIGHT_GREY = 7,
    VGA_COLOR_DARK_GREY = 8,
    VGA_COLOR_LIGHT_BLUE = 9,
    VGA_COLOR_LIGHT_GREEN = 10,
    VGA_COLOR_LIGHT_CYAN = 11,
    VGA_COLOR_LIGHT_RED = 12,
    VGA_COLOR_LIGHT_MAGENTA = 13,
    VGA_COLOR_LIGHT_BROWN = 14,
    VGA_COLOR_WHITE = 15,
};


namespace priv
{
    static inline u8 ReadRegister(u8 index)
    {
        WriteIO(0x3D4, index);
        return ReadIO(0x3D5);
    }

    static inline void WriteRegister(u8 index, u8 value)
    {
        WriteIO(0x3D4, index);
        WriteIO(0x3D5, value);
    }


    static inline void SetOperationMode(u8 mode)
    {
        WriteRegister(0x03, mode);
    }

    static inline void WriteVideoMemory(char c, u8 color, size_t x, size_t y)
    {
        const size_t offset = y * VGA_WIDTH + x;
        u16 byte = (u16)c | (u16)color << 8;

        videoBuffer[offset] = byte;
    }

    static inline void SetCursorPos(size_t x, size_t y)
    {
        size_t offset = y * VGA_WIDTH + x;

        WriteRegister(0x0E, (u8)(offset >> 8));
        WriteRegister(0x0F, (u8)(offset & 0xFF));
    }

    static inline void EnableCursor(u8 cursorStart, u8 cursorEnd)
    {
        u8 startValue = ReadRegister(0x0A);
        u8 endValue = ReadRegister(0x0B);

        startValue = (startValue & 0xC0) | (cursorStart & 0x0F);
        endValue = (endValue & 0xE0) | (cursorEnd & 0x0F);

        WriteRegister(0x0A, startValue);
        WriteRegister(0x0B, endValue);
    }

    static inline void DisableCursor(void)
    {
        u8 value = 0x01 << 5;
        WriteRegister(0x0A, value);
    }

    static void ScrollUp(void) {
        for (size_t y = 0; y < (VGA_HEIGHT - 1); y++) {
            for (size_t x = 0; x < VGA_WIDTH; x++) {
                const size_t index = y * VGA_WIDTH + x;
                const size_t nextIndex = (y + 1) * VGA_WIDTH + x;

                videoBuffer[index] = videoBuffer[nextIndex];
                videoBuffer[nextIndex] = 0;
            }
        }

        for (size_t x = 0; x < VGA_WIDTH; x++) {
            const size_t index = (VGA_HEIGHT - 1) * VGA_WIDTH + x;
            videoBuffer[index] = 0;
        }
    }

    static void SetWriteColor(VGAColor foreground, VGAColor background)
    {
        u8 colorByte = foreground | background << 4;
        writeColor = colorByte;
    }
}

bool IsAvailable(void)
{
    return true;
}

static void Initialize(void)
{
    column = 0;
    row = 0;

    videoBuffer = (u16*)0xB8000;

    priv::SetOperationMode(0x03);
    priv::SetWriteColor(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
}

static void WriteLineFeed(void)
{
    column = 0;

    if (row == (VGA_HEIGHT - 1)) {
        priv::ScrollUp();
    }
    else {
        row++;
    }
}

static void WriteChar(const char c)
{
    priv::WriteVideoMemory(c, writeColor, column, row);

    if (++column == VGA_WIDTH) {
        WriteLineFeed();
    }
}

static void EnableCursor(void)
{
    priv::EnableCursor(
        0,
        15
    );
}

static void UpdateCursor(void)
{
    priv::SetCursorPos(column, row);
}

static void DisableCursor(void)
{
    priv::DisableCursor();
}

static void Flush(void)
{

}

static void Clear(void)
{
    for (size_t y = 0; y < VGA_HEIGHT; y++) {
        for (size_t x = 0; x < VGA_WIDTH; x++) {
            priv::WriteVideoMemory(' ', writeColor, x, y);
        }
    }

    column = 0;
    row = 0;
}


struct ConsoleDriver vgaDriver = {
    "vgacon",
    IsAvailable,
    Initialize,
    WriteChar,
    WriteLineFeed,
    EnableCursor,
    UpdateCursor,
    DisableCursor,
    Flush,
    Clear
};
